/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../../node_modules/scrambo/lib/scramblers/NNN.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/scrambo/lib/scramblers/NNN.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("{/* jshint node: true */\n\nvar sequenceLength = 0;\nvar scrambler = function (size) {\n  var sequence = [];\n  var randomSource;\n\n  function appendmoves(sequence, axsl, tl, la) {\n    for (var sl = 0; sl < tl; sl++) {\n      if (axsl[sl]) {\n        var q = axsl[sl] - 1;\n        var sa = la;\n        var m = sl;\n        if (sl + sl + 1 >= tl) {\n          sa += 3;\n          m = tl - 1 - m;\n          q = 2 - q;\n        }\n        sequence[sequence.length] = (m * 6 + sa) * 4 + q;\n      }\n    }\n  }\n\n  function scramble() {\n    var tl = size - 1;\n    var axsl = [tl];\n    var axam = [0,0,0];\n    var la;\n    var n = 0;\n    la = -1;\n    sequence[0] = [];\n    for (var i = 0; i < tl; i++)\n      axsl[i] = 0;\n    axam[0] = axam[1] = axam[2] = 0;\n    var moved = 0;\n    while (sequence[0].length + moved < sequenceLength) {\n      var ax, sl, q;\n      do {\n        do {\n          ax = Math.floor(randomSource.random() * 3);\n          sl = Math.floor(randomSource.random() * tl);\n          q = Math.floor(randomSource.random() * 3);\n        } while (ax === la && axsl[sl] !== 0);\n      } while (ax === la);\n      if (ax != la) {\n        appendmoves(sequence[0], axsl, tl, la);\n        for (i = 0; i < tl; i++)\n          axsl[i] = 0;\n        axam[0] = axam[1] = axam[2] = 0;\n        moved = 0;\n        la = ax;\n      }\n      axam[q]++;\n      moved++;\n      axsl[sl] = q + 1;\n    }\n    appendmoves(sequence[0], axsl, tl, la);\n    sequence[0][sequence[0].length] = 0;\n  }\n\n  function scramblestring() {\n    var scramble = '',\n      j;\n    for (var i = 0; i < sequence[0].length - 1; i++) {\n      if (i !== 0)\n        scramble += ' ';\n      var k = sequence[0][i] >> 2;\n      j = k % 6;\n      k = (k - j) / 6;\n      if (k) {\n        scramble += 'dlburf'.charAt(j);\n      } else {\n        scramble += 'DLBURF'.charAt(j);\n      }\n      j = sequence[0][i] & 3;\n      if (j !== 0)\n        scramble += ' 2\\''.charAt(j);\n    }\n    return scramble;\n  }\n  var setRandomSource = function (src) {\n    randomSource = src;\n  };\n  var getRandomScramble = function () {\n    scramble();\n    return scramblestring(0);\n  };\n  var setScrambleLength = function (length) {\n    sequenceLength = length;\n  };\n  return {\n    initialize: setRandomSource,\n    getRandomScramble: getRandomScramble,\n    setScrambleLength: setScrambleLength\n  };\n};\nmodule.exports[222] = scrambler(2);\nmodule.exports[333] = scrambler(3);\nmodule.exports[444] = scrambler(4);\nmodule.exports[555] = scrambler(5);\nmodule.exports[666] = scrambler(6);\nmodule.exports[777] = scrambler(7);\n\n\n//# sourceURL=webpack://rubiks-bld-project/../../../node_modules/scrambo/lib/scramblers/NNN.js?\n}");

/***/ }),

/***/ "../../../node_modules/scrambo/lib/scramblers/clock.js":
/*!*************************************************************!*\
  !*** ../../../node_modules/scrambo/lib/scramblers/clock.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("{/* jshint node: true */\n\nvar scrambler = function () {\n  function getRandomScramble() {\n    var posit = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var p = 'dU';\n    var pegs = [0, 0, 0, 0];\n    var seq = [];\n    var i, j;\n    for (i = 0; i < 14; i++) {\n      seq[i] = Math.floor(randomSource.random() * 12) - 5;\n    }\n    var scrambleString = '';\n    var turnToString = function (turn, amount) {\n      var suffix;\n      if (amount === 0) {\n        return '';\n      } else if (amount === 1) {\n        suffix = '';\n      } else if (amount === -1) {\n        suffix = '\\'';\n      } else if (amount >= 0) {\n        suffix = '' + amount + '';\n      } else {\n        suffix = '' + -amount + '\\'';\n      }\n      return ' ' + turn + suffix;\n    };\n    var addToScrambleString = function (pegs, UAmount, dAmount) {\n      scrambleString += '[' + pegs + ']' + turnToString('U', UAmount) + turnToString('d', dAmount) + ' ';\n    };\n    addToScrambleString('UU/dd', seq[0], seq[4]);\n    addToScrambleString('dU/dU', seq[1], seq[5]);\n    addToScrambleString('dd/UU', seq[2], seq[6]);\n    addToScrambleString('Ud/Ud', seq[3], seq[7]);\n    addToScrambleString('dU/UU', seq[8], 0);\n    addToScrambleString('Ud/UU', seq[9], 0);\n    addToScrambleString('UU/Ud', seq[10], 0);\n    addToScrambleString('UU/dU', seq[11], 0);\n    addToScrambleString('UU/UU', seq[12], 0);\n    addToScrambleString('dd/dd', 0, seq[13]);\n    addToScrambleString(p[pegs[0]] + p[pegs[1]] + '/' + p[pegs[2]] + p[pegs[3]], 0, 0);\n    return scrambleString;\n  }\n  var randomSource;\n  var setRandomSource = function (src) {\n    randomSource = src;\n  };\n  return {\n    initialize: setRandomSource,\n    getRandomScramble: getRandomScramble,\n    setScrambleLength: null\n  };\n}();\nmodule.exports = scrambler;\n\n\n//# sourceURL=webpack://rubiks-bld-project/../../../node_modules/scrambo/lib/scramblers/clock.js?\n}");

/***/ }),

/***/ "../../../node_modules/scrambo/lib/scramblers/minx.js":
/*!************************************************************!*\
  !*** ../../../node_modules/scrambo/lib/scramblers/minx.js ***!
  \************************************************************/
/***/ ((module) => {

eval("{/* jshint node: true */\n/*\n *\n * Program by Cl√©ment Gallet, based on earlier work by Jaap Scherphuis. Idea by Stefan Pochmann.\n *\n * ## Notation:\n * D means all layers below the U face together in one move.\n * R means all layers right from the L face together in one move.\n * ++ means 2/5 move clockwise (144 degrees), -- means 2/5 move counterclockwise (-144 degrees).\n * U is the regular move of the U face, according to standard cube notation.\n *\n */\n\nvar scrambler = function () {\n  var linelen = 71;\n  var randomSource;\n\n  var permU = [4, 0, 1, 2, 3, 9, 5, 6, 7, 8, 10, 11, 12, 13, 58, 59, 16, 17, 18, 63, 20, 21, 22, 23, 24, 14, 15, 27, 28, 29, 19, 31, 32, 33, 34, 35, 25, 26, 38, 39, 40, 30, 42, 43, 44, 45, 46, 36, 37, 49, 50, 51, 41, 53, 54, 55, 56, 57, 47, 48, 60, 61, 62, 52, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131];\n  var permUi = [1, 2, 3, 4, 0, 6, 7, 8, 9, 5, 10, 11, 12, 13, 25, 26, 16, 17, 18, 30, 20, 21, 22, 23, 24, 36, 37, 27, 28, 29, 41, 31, 32, 33, 34, 35, 47, 48, 38, 39, 40, 52, 42, 43, 44, 45, 46, 58, 59, 49, 50, 51, 63, 53, 54, 55, 56, 57, 14, 15, 60, 61, 62, 19, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131];\n  var permD2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 33, 34, 35, 14, 15, 38, 39, 40, 19, 42, 43, 44, 45, 46, 25, 26, 49, 50, 51, 30, 53, 54, 55, 56, 57, 36, 37, 60, 61, 62, 41, 64, 65, 11, 12, 13, 47, 48, 16, 17, 18, 52, 20, 21, 22, 23, 24, 58, 59, 27, 28, 29, 63, 31, 32, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 124, 125, 121, 122, 123, 129, 130, 126, 127, 128, 131];\n  var permD2i = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 44, 45, 46, 14, 15, 49, 50, 51, 19, 53, 54, 55, 56, 57, 25, 26, 60, 61, 62, 30, 64, 65, 11, 12, 13, 36, 37, 16, 17, 18, 41, 20, 21, 22, 23, 24, 47, 48, 27, 28, 29, 52, 31, 32, 33, 34, 35, 58, 59, 38, 39, 40, 63, 42, 43, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 123, 124, 125, 121, 122, 128, 129, 130, 126, 127, 131];\n  var permR2 = [81, 77, 78, 3, 4, 86, 82, 83, 8, 85, 87, 122, 123, 124, 125, 121, 127, 128, 129, 130, 126, 131, 89, 90, 24, 25, 88, 94, 95, 29, 97, 93, 98, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 26, 22, 23, 48, 30, 31, 27, 28, 53, 32, 69, 70, 66, 67, 68, 74, 75, 71, 72, 73, 76, 101, 102, 103, 99, 100, 106, 107, 108, 104, 105, 109, 46, 47, 79, 80, 45, 51, 52, 84, 49, 50, 54, 0, 1, 2, 91, 92, 5, 6, 7, 96, 9, 10, 15, 11, 12, 13, 14, 20, 16, 17, 18, 19, 21, 113, 114, 110, 111, 112, 118, 119, 115, 116, 117, 120, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65];\n  var permR2i = [88, 89, 90, 3, 4, 93, 94, 95, 8, 97, 98, 100, 101, 102, 103, 99, 105, 106, 107, 108, 104, 109, 46, 47, 24, 25, 45, 51, 52, 29, 49, 50, 54, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 81, 77, 78, 48, 85, 86, 82, 83, 53, 87, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 57, 58, 59, 55, 56, 62, 63, 64, 60, 61, 65, 1, 2, 79, 80, 0, 6, 7, 84, 9, 5, 10, 26, 22, 23, 91, 92, 31, 27, 28, 96, 30, 32, 69, 70, 66, 67, 68, 74, 75, 71, 72, 73, 76, 112, 113, 114, 110, 111, 117, 118, 119, 115, 116, 120, 15, 11, 12, 13, 14, 20, 16, 17, 18, 19, 21];\n\n  function getRandomScramble() {\n    var scramble = '';\n    for (var i = 0; i < linelen - 1; i++) {\n      var sequence = Math.floor(randomSource.random() * 2);\n      if (i % 2) {\n        if (sequence) {\n          scramble += 'D++ ';\n        } else {\n          scramble += 'D-- ';\n        }\n      } else {\n        if (sequence) {\n          scramble += 'R++ ';\n        } else {\n          scramble += 'R-- ';\n        }\n      }\n    }\n    scramble += 'U\\'';\n    return scramble;\n  }\n  var setRandomSource = function (src) {\n    randomSource = src;\n  };\n  var setScrambleLength = function (length) {\n    linelen = length;\n  };\n  return {\n    initialize: setRandomSource,\n    getRandomScramble: getRandomScramble,\n    setScrambleLength: setScrambleLength\n  };\n}();\nmodule.exports = scrambler;\n\n\n//# sourceURL=webpack://rubiks-bld-project/../../../node_modules/scrambo/lib/scramblers/minx.js?\n}");

/***/ }),

/***/ "../../../node_modules/scrambo/lib/scramblers/pyram.js":
/*!*************************************************************!*\
  !*** ../../../node_modules/scrambo/lib/scramblers/pyram.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("{/* jshint node: true */\n\n/* Base script written by Jaap Scherphuis, jaapsch a t yahoo d o t com */\n/* Javascript written by Syoji Takamatsu, , red_dragon a t honki d o t net */\n/* Random-State modification by Lucas Garron (lucasg a t gmx d o t de / garron.us) in collaboration with Michael Gottlieb (mzrg.com)*/\n/* Optimal modification by Michael Gottlieb (qqwref a t gmail d o t com) from Jaap's code */\n\nvar scrambler = function () {\n  var seq = [];\n  var scramblestring = '';\n\n  function scramble() {\n    var i, j, ls, t;\n    initbrd();\n    dosolve();\n    scramblestring = '';\n    for (i = 0; i < sol.length; i++) {\n      scramblestring += ['U', 'L', 'R', 'B']\n                           [sol[i] & 7] + ['', '\\'']\n                           [(sol[i] & 8) / 8] + ' ';\n    }\n    var tips = ['l', 'r', 'b', 'u'];\n    for (i = 0; i < 4; i++) {\n      j = Math.floor(randomSource.random() * 3);\n      if (j < 2) {\n        scramblestring += tips[i] + ['', '\\''][j] + ' ';\n      }\n    }\n  }\n  var posit = [];\n  var edt;\n  var perm = [];\n  var twst = [];\n  var permmv = [];\n  var twstmv = [];\n  var sol = [];\n  var pcperm = [];\n  var pcori = [];\n\n  function initbrd() {\n    posit = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3];\n    sol.length = 0;\n  }\n  var edges = [2, 11, 1, 20, 4, 31, 10, 19, 13, 29, 22, 28];\n  var movelist = [];\n  movelist[0] = [0, 18, 9, 6, 24, 15, 1, 19, 11, 2, 20, 10]; //U\n  movelist[1] = [23, 3, 30, 26, 7, 34, 22, 1, 31, 20, 4, 28]; //L\n  movelist[2] = [5, 14, 32, 8, 17, 35, 4, 11, 29, 2, 13, 31]; //R\n  movelist[3] = [12, 21, 27, 16, 25, 33, 13, 19, 28, 10, 22, 29]; //B\n  function dosolve() {\n    var a, b, c, l, t = 0,\n      q = 0;\n    var parity = 0;\n    var temp;\n    pcperm = [0, 1, 2, 3, 4, 5];\n    for (var i = 0; i < 4; i++) {\n      var other = i + Math.floor((6 - i) * randomSource.random());\n      temp = pcperm[i];\n      pcperm[i] = pcperm[other];\n      pcperm[other] = temp;\n      if (i !== other)\n        parity++;\n    }\n    if (parity % 2 === 1) {\n      temp = pcperm[4];\n      pcperm[4] = pcperm[5];\n      pcperm[5] = temp;\n    }\n    parity = 0;\n    pcori = [];\n    for (i = 0; i < 5; i++) {\n      pcori[i] = Math.floor(2 * randomSource.random());\n      parity += pcori[i];\n    }\n    pcori[5] = parity % 2;\n    for (i = 6; i < 10; i++) {\n      pcori[i] = Math.floor(3 * randomSource.random());\n    }\n    for (a = 0; a < 6; a++) {\n      b = 0;\n      for (c = 0; c < 6; c++) {\n        if (pcperm[c] === a)\n          break;\n        if (pcperm[c] > a)\n          b++;\n      }\n      q = q * (6 - a) + b;\n    }\n    for (a = 9; a >= 6; a--) {\n      t = t * 3 + pcori[a];\n    }\n    for (a = 4; a >= 0; a--) {\n      t = t * 2 + pcori[a];\n    }\n    if (q !== 0 || t !== 0) {\n      for (l = 7; l < 12; l++) {\n        if (search(q, t, l, -1))\n          break;\n      }\n    }\n  }\n\n  function search(q, t, l, lm) {\n    if (l === 0) {\n      if (q === 0 && t === 0) {\n        return true;\n      }\n    } else {\n      if (perm[q] > l || twst[t] > l)\n        return false;\n      var p, s, a, m;\n      for (m = 0; m < 4; m++) {\n        if (m !== lm) {\n          p = q;\n          s = t;\n          for (a = 0; a < 2; a++) {\n            p = permmv[p][m];\n            s = twstmv[s][m];\n            sol[sol.length] = m + 8 * a;\n            if (search(p, s, l - 1, m))\n              return true;\n            sol.length--;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  function calcperm() {\n    var c, p, q, l, m, n;\n    for (p = 0; p < 720; p++) {\n      perm[p] = -1;\n      permmv[p] = [];\n      for (m = 0; m < 4; m++) {\n        permmv[p][m] = getprmmv(p, m);\n      }\n    }\n    perm[0] = 0;\n    for (l = 0; l <= 6; l++) {\n      n = 0;\n      for (p = 0; p < 720; p++) {\n        if (perm[p] === l) {\n          for (m = 0; m < 4; m++) {\n            q = p;\n            for (c = 0; c < 2; c++) {\n              q = permmv[q][m];\n              if (perm[q] === -1) {\n                perm[q] = l + 1;\n                n++;\n              }\n            }\n          }\n        }\n      }\n    }\n    for (p = 0; p < 2592; p++) {\n      twst[p] = -1;\n      twstmv[p] = [];\n      for (m = 0; m < 4; m++) {\n        twstmv[p][m] = gettwsmv(p, m);\n      }\n    }\n    twst[0] = 0;\n    for (l = 0; l <= 5; l++) {\n      n = 0;\n      for (p = 0; p < 2592; p++) {\n        if (twst[p] === l) {\n          for (m = 0; m < 4; m++) {\n            q = p;\n            for (c = 0; c < 2; c++) {\n              q = twstmv[q][m];\n              if (twst[q] === -1) {\n                twst[q] = l + 1;\n                n++;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function getprmmv(p, m) {\n    var a, b, c;\n    var ps = [];\n    var q = p;\n    for (a = 1; a <= 6; a++) {\n      c = Math.floor(q / a);\n      b = q - a * c;\n      q = c;\n      for (c = a - 1; c >= b; c--)\n        ps[c + 1] = ps[c];\n      ps[b] = 6 - a;\n    }\n    if (m === 0) {\n      cycle3(ps, 0, 3, 1);\n    } else if (m === 1) {\n      cycle3(ps, 1, 5, 2);\n    } else if (m === 2) {\n      cycle3(ps, 0, 2, 4);\n    } else if (m === 3) {\n      cycle3(ps, 3, 4, 5);\n    }\n    q = 0;\n    for (a = 0; a < 6; a++) {\n      b = 0;\n      for (c = 0; c < 6; c++) {\n        if (ps[c] === a)\n          break;\n        if (ps[c] > a)\n          b++;\n      }\n      q = q * (6 - a) + b;\n    }\n    return q;\n  }\n\n  function gettwsmv(p, m) {\n    var a, b, c, d = 0;\n    var ps = [];\n    var q = p;\n    for (a = 0; a <= 4; a++) {\n      ps[a] = q & 1;\n      q >>= 1;\n      d ^= ps[a];\n    }\n    ps[5] = d;\n    for (a = 6; a <= 9; a++) {\n      c = Math.floor(q / 3);\n      b = q - 3 * c;\n      q = c;\n      ps[a] = b;\n    }\n    if (m === 0) {\n      ps[6]++;\n      if (ps[6] === 3)\n        ps[6] = 0;\n      cycle3(ps, 0, 3, 1);\n      ps[1] ^= 1;\n      ps[3] ^= 1;\n    } else if (m === 1) {\n      ps[7]++;\n      if (ps[7] === 3)\n        ps[7] = 0;\n      cycle3(ps, 1, 5, 2);\n      ps[2] ^= 1;\n      ps[5] ^= 1;\n    } else if (m === 2) {\n      ps[8]++;\n      if (ps[8] === 3)\n        ps[8] = 0;\n      cycle3(ps, 0, 2, 4);\n      ps[0] ^= 1;\n      ps[2] ^= 1;\n    } else if (m === 3) {\n      ps[9]++;\n      if (ps[9] === 3)\n        ps[9] = 0;\n      cycle3(ps, 3, 4, 5);\n      ps[3] ^= 1;\n      ps[4] ^= 1;\n    }\n    q = 0;\n    for (a = 9; a >= 6; a--) {\n      q = q * 3 + ps[a];\n    }\n    for (a = 4; a >= 0; a--) {\n      q = q * 2 + ps[a];\n    }\n    return q;\n  }\n\n  function cycle3(arr, i1, i2, i3) {\n    var c = arr[i1];\n    arr[i1] = arr[i2];\n    arr[i2] = arr[i3];\n    arr[i3] = c;\n  }\n  var randomSource;\n  var setRandomSource = function (src) {\n    randomSource = src;\n  };\n  var getRandomScramble = function () {\n    calcperm();\n    scramble();\n    return scramblestring;\n  };\n  var initializeFull = function (iniRandomSource) {\n    setRandomSource(iniRandomSource);\n  };\n  var setScrambleLength = function (length) {\n    return null;\n  };\n  return {\n    initialize: setRandomSource,\n    getRandomScramble: getRandomScramble,\n    setScrambleLength: setScrambleLength\n  };\n}();\nmodule.exports = scrambler;\n\n\n//# sourceURL=webpack://rubiks-bld-project/../../../node_modules/scrambo/lib/scramblers/pyram.js?\n}");

/***/ }),

/***/ "../../../node_modules/scrambo/lib/scramblers/skewb.js":
/*!*************************************************************!*\
  !*** ../../../node_modules/scrambo/lib/scramblers/skewb.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("{/*\tPort by Caleb Hoover from Shuang Chen's skewb scrambler.\n\tSource: https://github.com/cubing/qqTimer/blob/mzrg/index.htm#L2158 \n\tDesigned to work with Scrambo\n*/\n\nvar scrambler = function() {\n\tvar randomSource = Math;\n\tvar setRandomSource = function(src) {\n\t\trandomSource = src;\n\t};\n\tvar length = 11;\n\tvar setScrambleLength = function(len) {\n\t\tlength = len;\n\t};\n\n\tvar initialize = function(iniRandomSource) {\n\t\trandomSource = iniRandomSource;\n\t}\n\n\tfunction getRandomScramble() {\n\t\tfunction t(e) {\n\t\t\tvar t = arguments.length - 1,\n\t\t\t\tn = e[arguments[t]];\n\t\t\tfor (var r = t; r > 1; r--) {\n\t\t\t\te[arguments[r]] = e[arguments[r - 1]]\n\t\t\t}\n\t\t\te[arguments[1]] = n\n\t\t}\n\n\t\tfunction n(e, t) {\n\t\t\treturn e[t >> 3] >> ((t & 7) << 2) & 15\n\t\t}\n\n\t\tfunction r(e, t, n, r) {\n\t\t\tfor (var i = 0; i < r; i++) {\n\t\t\t\te[i] = [];\n\t\t\t\tfor (var s = 0; s < t; s++) {\n\t\t\t\t\te[i][s] = n(s, i)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction i(e, t, r, i, s, o, u) {\n\t\t\tvar a = Array.isArray(s);\n\t\t\tfor (var f = 0, l = r + 7 >>> 3; f < l; f++) {\n\t\t\t\te[f] = -1\n\t\t\t}\n\t\t\te[t >> 3] ^= 15 << ((t & 7) << 2);\n\t\t\tfor (var c = 0; c <= i; c++) {\n\t\t\t\tvar h = c + 1 ^ 15;\n\t\t\t\tfor (var p = 0; p < r; p++) {\n\t\t\t\t\tif (n(e, p) == c) {\n\t\t\t\t\t\tfor (var d = 0; d < o; d++) {\n\t\t\t\t\t\t\tvar v = p;\n\t\t\t\t\t\t\tfor (var m = 0; m < u; m++) {\n\t\t\t\t\t\t\t\tv = a ? s[d][v] : s(v, d);\n\t\t\t\t\t\t\t\tif (n(e, v) == 15) {\n\t\t\t\t\t\t\t\t\te[v >> 3] ^= h << ((v & 7) << 2)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction s(e, t, r, i, o) {\n\t\t\tif (0 == r) return 0 == e && 0 == t;\n\t\t\tif (n(a, e) > r || n(f, t) > r) return !1;\n\t\t\tfor (var u = 0; 4 > u; u++)\n\t\t\t\tif (u != i)\n\t\t\t\t\tfor (var h = e, p = t, d = 0; 2 > d; d++)\n\t\t\t\t\t\tif (h = l[u][h], p = c[u][p], s(h, p, r - 1, u, o)) return o.push(u * 2 + (1 - d)), !0;\n\t\t\treturn !1\n\t\t}\n\n\t\tfunction o(e, n) {\n\t\t\tvar r = e % 12;\n\t\t\te = ~~(e / 12);\n\t\t\tfor (var i = [], s = 5517840, o = 0, u = 0; 5 > u; u++) {\n\t\t\t\tvar a = h[5 - u],\n\t\t\t\t\tf = ~~(e / a),\n\t\t\t\t\te = e - f * a,\n\t\t\t\t\to = o ^ f,\n\t\t\t\t\tf = f << 2;\n\t\t\t\ti[u] = s >> f & 15;\n\t\t\t\ta = (1 << f) - 1;\n\t\t\t\ts = (s & a) + (s >> 4 & ~a)\n\t\t\t}\n\t\t\t0 == (o & 1) ? i[5] = s : (i[5] = i[4], i[4] = s);\n\t\t\t0 == n && t(i, 0, 3, 1);\n\t\t\t2 == n && t(i, 1, 5, 2);\n\t\t\t1 == n && t(i, 0, 2, 4);\n\t\t\t3 == n && t(i, 3, 4, 5);\n\t\t\te = 0;\n\t\t\ts = 5517840;\n\t\t\tfor (u = 0; 4 > u; u++) f = i[u] << 2, e *= 6 - u, e += s >> f & 15, s -= 1118480 << f;\n\t\t\treturn e * 12 + p[r][n]\n\t\t}\n\n\t\tfunction u(e, t) {\n\t\t\tvar n = [];\n\t\t\tvar r = [];\n\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\tn[i] = e % 3;\n\t\t\t\te = ~~(e / 3)\n\t\t\t}\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\tr[i] = e % 3;\n\t\t\t\te = ~~(e / 3)\n\t\t\t}\n\t\t\tr[3] = (6 - r[0] - r[1] - r[2]) % 3;\n\t\t\tn[t] = (n[t] + 1) % 3;\n\t\t\tvar s;\n\t\t\tif (t == 0) {\n\t\t\t\tvar s = r[0];\n\t\t\t\tr[0] = r[2] + 2;\n\t\t\t\tr[2] = r[1] + 2;\n\t\t\t\tr[1] = s + 2\n\t\t\t} else if (t == 1) {\n\t\t\t\tvar s = r[0];\n\t\t\t\tr[0] = r[1] + 2;\n\t\t\t\tr[1] = r[3] + 2;\n\t\t\t\tr[3] = s + 2\n\t\t\t} else if (t == 2) {\n\t\t\t\tvar s = r[0];\n\t\t\t\tr[0] = r[3] + 2;\n\t\t\t\tr[3] = r[2] + 2;\n\t\t\t\tr[2] = s + 2\n\t\t\t} else if (t == 3) {\n\t\t\t\tvar s = r[1];\n\t\t\t\tr[1] = r[2] + 2;\n\t\t\t\tr[2] = r[3] + 2;\n\t\t\t\tr[3] = s + 2\n\t\t\t}\n\t\t\tfor (var i = 2; i >= 0; i--) {\n\t\t\t\te = e * 3 + r[i] % 3\n\t\t\t}\n\t\t\tfor (var i = 3; i >= 0; i--) {\n\t\t\t\te = e * 3 + n[i]\n\t\t\t}\n\t\t\treturn e\n\t\t}\n\t\tvar a = [],\n\t\t\tf = [],\n\t\t\tl = [],\n\t\t\tc = [];\n\t\tvar h = [1, 1, 1, 3, 12, 60, 360];\n\t\tvar p = [\n\t\t\t[6, 5, 10, 1],\n\t\t\t[9, 7, 4, 2],\n\t\t\t[3, 11, 8, 0],\n\t\t\t[10, 1, 6, 5],\n\t\t\t[0, 8, 11, 3],\n\t\t\t[7, 9, 2, 4],\n\t\t\t[4, 2, 9, 7],\n\t\t\t[11, 3, 0, 8],\n\t\t\t[1, 10, 5, 6],\n\t\t\t[8, 0, 3, 11],\n\t\t\t[2, 4, 7, 9],\n\t\t\t[5, 6, 1, 10]\n\t\t];\n\t\tvar d = [0, 1, 2, 0, 2, 1, 1, 2, 0, 2, 1, 0];\n\t\tvar v, m, y = [];\n\t\tr(l, 4320, o, 4);\n\t\ti(a, 0, 4320, 7, l, 4, 2);\n\t\tr(c, 2187, u, 4);\n\t\ti(f, 0, 2187, 6, c, 4, 2);\n\t\tdo {\n\t\t\tv = 0 | randomSource.random() * 4320;\n\t\t\tm = 0 | randomSource.random() * 2187\n\t\t} while (v == 0 && m == 0 || d[v % 12] != (m + ~~(m / 3) + ~~(m / 9) + ~~(m / 27)) % 3);\n\t\tfor (; 99 > length && !s(v, m, length, -1, y); length++) {}\n\n\t\tvar scramble = [];\n\t\tvar w = [\"L\", \"R\", \"B\", \"U\"];\n\t\tfor (var u = 0; u < y.length; u++) {\n\t\t\tvar E = y[u] >> 1;\n\t\t\tvar S = y[u] & 1;\n\t\t\tif (E == 2) {\n\t\t\t\tfor (var l = 0; l <= S; l++) {\n\t\t\t\t\tvar x = w[0];\n\t\t\t\t\tw[0] = w[1];\n\t\t\t\t\tw[1] = w[3];\n\t\t\t\t\tw[3] = x\n\t\t\t\t}\n\t\t\t}\n\t\t\tscramble.push(w[E] + (S == 1 ? \"'\" : \"\"))\n\t\t}\n\t\treturn scramble.join(\" \")\n\t}\n\n\treturn {\n\t\tinitialize: initialize,\n\t\tsetRandomSource: setRandomSource,\n\t\tgetRandomScramble: getRandomScramble.bind(11),\n\t\tsetScrambleLength: setScrambleLength\n\t};\n}();\nmodule.exports = scrambler;\n\n//# sourceURL=webpack://rubiks-bld-project/../../../node_modules/scrambo/lib/scramblers/skewb.js?\n}");

/***/ }),

/***/ "../../../node_modules/scrambo/lib/scramblers/sq1.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/scrambo/lib/scramblers/sq1.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("{/* jshint node: true */\n\nvar scrambler = function () {\n  function FullCube_copy(obj, c) {\n    obj.ul = c.ul;\n    obj.ur = c.ur;\n    obj.dl = c.dl;\n    obj.dr = c.dr;\n    obj.ml = c.ml;\n  }\n\n  function FullCube_doMove(obj, move) {\n    var temp;\n    move <<= 2;\n    if (move > 24) {\n      move = 48 - move;\n      temp = obj.ul;\n      obj.ul = (~~obj.ul >> move | obj.ur << 24 - move) & 16777215;\n      obj.ur = (~~obj.ur >> move | temp << 24 - move) & 16777215;\n    } else if (move > 0) {\n      temp = obj.ul;\n      obj.ul = (obj.ul << move | ~~obj.ur >> 24 - move) & 16777215;\n      obj.ur = (obj.ur << move | ~~temp >> 24 - move) & 16777215;\n    } else if (move === 0) {\n      temp = obj.ur;\n      obj.ur = obj.dl;\n      obj.dl = temp;\n      obj.ml = 1 - obj.ml;\n    } else if (move >= -24) {\n      move = -move;\n      temp = obj.dl;\n      obj.dl = (obj.dl << move | ~~obj.dr >> 24 - move) & 16777215;\n      obj.dr = (obj.dr << move | ~~temp >> 24 - move) & 16777215;\n    } else if (move < -24) {\n      move = 48 + move;\n      temp = obj.dl;\n      obj.dl = (~~obj.dl >> move | obj.dr << 24 - move) & 16777215;\n      obj.dr = (~~obj.dr >> move | temp << 24 - move) & 16777215;\n    }\n  }\n\n  function FullCube_getParity(obj) {\n    var a, b, cnt, i, p;\n    cnt = 0;\n    obj.arr[0] = FullCube_pieceAt(obj, 0);\n    for (i = 1; i < 24; ++i) {\n      FullCube_pieceAt(obj, i) !== obj.arr[cnt] && (obj.arr[++cnt] = FullCube_pieceAt(obj, i));\n    }\n    p = 0;\n    for (a = 0; a < 16; ++a) {\n      for (b = a + 1; b < 16; ++b) {\n        obj.arr[a] > obj.arr[b] && (p ^= 1);\n      }\n    }\n    return p;\n  }\n\n  function FullCube_getShapeIdx(obj) {\n    var dlx, drx, ulx, urx;\n    urx = obj.ur & 1118481;\n    urx |= ~~urx >> 3;\n    urx |= ~~urx >> 6;\n    urx = urx & 15 | ~~urx >> 12 & 48;\n    ulx = obj.ul & 1118481;\n    ulx |= ~~ulx >> 3;\n    ulx |= ~~ulx >> 6;\n    ulx = ulx & 15 | ~~ulx >> 12 & 48;\n    drx = obj.dr & 1118481;\n    drx |= ~~drx >> 3;\n    drx |= ~~drx >> 6;\n    drx = drx & 15 | ~~drx >> 12 & 48;\n    dlx = obj.dl & 1118481;\n    dlx |= ~~dlx >> 3;\n    dlx |= ~~dlx >> 6;\n    dlx = dlx & 15 | ~~dlx >> 12 & 48;\n    return Shape_getShape2Idx(FullCube_getParity(obj) << 24 | ulx << 18 | urx << 12 | dlx << 6 | drx);\n  }\n\n  function FullCube_getSquare(obj, sq) {\n    var a, b;\n    for (a = 0; a < 8; ++a) {\n      obj.prm[a] = ~~ (~~FullCube_pieceAt(obj, a * 3 + 1) >> 1 << 24) >> 24;\n    }\n    sq.cornperm = get8Perm(obj.prm);\n    sq.topEdgeFirst = FullCube_pieceAt(obj, 0) === FullCube_pieceAt(obj, 1);\n    a = sq.topEdgeFirst ? 2 : 0;\n    for (b = 0; b < 4; a += 3, ++b)\n      obj.prm[b] = ~~ (~~FullCube_pieceAt(obj, a) >> 1 << 24) >> 24;\n    sq.botEdgeFirst = FullCube_pieceAt(obj, 12) === FullCube_pieceAt(obj, 13);\n    a = sq.botEdgeFirst ? 14 : 12;\n    for (; b < 8; a += 3, ++b)\n      obj.prm[b] = ~~ (~~FullCube_pieceAt(obj, a) >> 1 << 24) >> 24;\n    sq.edgeperm = get8Perm(obj.prm);\n    sq.ml = obj.ml;\n  }\n\n  function FullCube_pieceAt(obj, idx) {\n    var ret;\n    idx < 6 ? ret = ~~obj.ul >> (5 - idx << 2) : idx < 12 ? ret = ~~obj.ur >> (11 - idx << 2) : idx < 18 ? ret = ~~obj.dl >> (17 - idx << 2) : ret = ~~obj.dr >> (23 - idx << 2);\n    return~~ ((ret & 15) << 24) >> 24;\n  }\n\n  function FullCube_setPiece(obj, idx, value) {\n    if (idx < 6) {\n      obj.ul &= ~(15 << (5 - idx << 2));\n      obj.ul |= value << (5 - idx << 2);\n    } else if (idx < 12) {\n      obj.ur &= ~(15 << (11 - idx << 2));\n      obj.ur |= value << (11 - idx << 2);\n    } else if (idx < 18) {\n      obj.dl &= ~(15 << (17 - idx << 2));\n      obj.dl |= value << (17 - idx << 2);\n    } else {\n      obj.dr &= ~(15 << (23 - idx << 2));\n      obj.dr |= value << (23 - idx << 2);\n    }\n  }\n\n  function FullCube_FullCube__Ljava_lang_String_2V() {\n    this.arr = [];\n    this.prm = [];\n  }\n\n  function FullCube_randomCube() {\n    var f, i, shape, edge, corner, n_edge, n_corner, rnd, m;\n    f = new FullCube_FullCube__Ljava_lang_String_2V();\n    shape = Shape_ShapeIdx[~~(square1SolverRandomSource.random() * 3678)];\n    corner = 19088743 << 1 | 286331153;\n    edge = 19088743 << 1;\n    n_corner = n_edge = 8;\n    for (i = 0; i < 24; i++) {\n      if ((shape >> i & 1) === 0) {\n        rnd = ~~ (square1SolverRandomSource.random() * n_edge) << 2;\n        FullCube_setPiece(f, 23 - i, edge >> rnd & 15);\n        m = (1 << rnd) - 1;\n        edge = (edge & m) + (edge >> 4 & ~m);\n        --n_edge;\n      } else {\n        rnd = ~~ (square1SolverRandomSource.random() * n_corner) << 2;\n        FullCube_setPiece(f, 23 - i, corner >> rnd & 15);\n        FullCube_setPiece(f, 22 - i, corner >> rnd & 15);\n        m = (1 << rnd) - 1;\n        corner = (corner & m) + (corner >> 4 & ~m);\n        --n_corner;\n        ++i;\n      }\n    }\n    f.ml = ~~ (square1SolverRandomSource.random() * 2);\n    return f;\n  }\n\n  var FullCube_gen;\n\n  function Search_init2(obj) {\n    var corner, edge, i, j, ml, prun;\n    FullCube_copy(obj.Search_d, obj.Search_c);\n    for (i = 0; i < obj.Search_length1; ++i) {\n      FullCube_doMove(obj.Search_d, obj.Search_move[i]);\n    }\n    FullCube_getSquare(obj.Search_d, obj.Search_sq);\n    edge = obj.Search_sq.edgeperm;\n    corner = obj.Search_sq.cornperm;\n    ml = obj.Search_sq.ml;\n    prun = Math.max(SquarePrun[obj.Search_sq.edgeperm << 1 | ml], SquarePrun[obj.Search_sq.cornperm << 1 | ml]);\n    for (i = prun; i < obj.Search_maxlen2; ++i) {\n      if (Search_phase2(obj, edge, corner, obj.Search_sq.topEdgeFirst, obj.Search_sq.botEdgeFirst, ml, i, obj.Search_length1, 0)) {\n        for (j = 0; j < i; ++j) {\n          FullCube_doMove(obj.Search_d, obj.Search_move[obj.Search_length1 + j]);\n        }\n        obj.Search_sol_string = Search_move2string(obj, i + obj.Search_length1);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function Search_move2string(obj, len) {\n    var s = '';\n    var top = 0,\n      bottom = 0;\n    for (var i = len - 1; i >= 0; i--) {\n      var val = obj.Search_move[i];\n      if (val > 0) {\n        val = 12 - val;\n        top = val > 6 ? val - 12 : val;\n      } else if (val < 0) {\n        val = 12 + val;\n        bottom = val > 6 ? val - 12 : val;\n      } else {\n        if (top === 0 && bottom === 0) {\n          s += ' / ';\n        } else {\n          s += '(' + top + ', ' + bottom + ') / ';\n        }\n        top = bottom = 0;\n      }\n    }\n    if (top === 0 && bottom === 0) {} else {\n      s += '(' + top + ', ' + bottom + ')';\n    }\n    return s;\n  }\n\n  function Search_phase1(obj, shape, prunvalue, maxl, depth, lm) {\n    var m, prunx, shapex;\n    if (prunvalue === 0 && maxl < 4) {\n      return maxl === 0 && Search_init2(obj);\n    }\n    if (lm !== 0) {\n      shapex = Shape_TwistMove[shape];\n      prunx = ShapePrun[shapex];\n      if (prunx < maxl) {\n        obj.Search_move[depth] = 0;\n        if (Search_phase1(obj, shapex, prunx, maxl - 1, depth + 1, 0)) {\n          return true;\n        }\n      }\n    }\n    shapex = shape;\n    if (lm <= 0) {\n      m = 0;\n      while (true) {\n        m += Shape_TopMove[shapex];\n        shapex = ~~m >> 4;\n        m &= 15;\n        if (m >= 12) {\n          break;\n        }\n        prunx = ShapePrun[shapex];\n        if (prunx > maxl) {\n          break;\n        } else if (prunx < maxl) {\n          obj.Search_move[depth] = m;\n          if (Search_phase1(obj, shapex, prunx, maxl - 1, depth + 1, 1)) {\n            return true;\n          }\n        }\n      }\n    }\n    shapex = shape;\n    if (lm <= 1) {\n      m = 0;\n      while (true) {\n        m += Shape_BottomMove[shapex];\n        shapex = ~~m >> 4;\n        m &= 15;\n        if (m >= 6) {\n          break;\n        }\n        prunx = ShapePrun[shapex];\n        if (prunx > maxl) {\n          break;\n        } else if (prunx < maxl) {\n          obj.Search_move[depth] = -m;\n          if (Search_phase1(obj, shapex, prunx, maxl - 1, depth + 1, 2)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  function Search_phase2(obj, edge, corner, topEdgeFirst, botEdgeFirst, ml, maxl, depth, lm) {\n    var botEdgeFirstx, cornerx, edgex, m, prun1, prun2, topEdgeFirstx;\n    if (maxl === 0 && !topEdgeFirst && botEdgeFirst) {\n      return true;\n    }\n    if (lm !== 0 && topEdgeFirst === botEdgeFirst) {\n      edgex = Square_TwistMove[edge];\n      cornerx = Square_TwistMove[corner];\n      if (SquarePrun[edgex << 1 | 1 - ml] < maxl && SquarePrun[cornerx << 1 | 1 - ml] < maxl) {\n        obj.Search_move[depth] = 0;\n        if (Search_phase2(obj, edgex, cornerx, topEdgeFirst, botEdgeFirst, 1 - ml, maxl - 1, depth + 1, 0)) {\n          return true;\n        }\n      }\n    }\n    if (lm <= 0) {\n      topEdgeFirstx = !topEdgeFirst;\n      edgex = topEdgeFirstx ? Square_TopMove[edge] : edge;\n      cornerx = topEdgeFirstx ? corner : Square_TopMove[corner];\n      m = topEdgeFirstx ? 1 : 2;\n      prun1 = SquarePrun[edgex << 1 | ml];\n      prun2 = SquarePrun[cornerx << 1 | ml];\n      while (m < 12 && prun1 <= maxl && prun1 <= maxl) {\n        if (prun1 < maxl && prun2 < maxl) {\n          obj.Search_move[depth] = m;\n          if (Search_phase2(obj, edgex, cornerx, topEdgeFirstx, botEdgeFirst, ml, maxl - 1, depth + 1, 1)) {\n            return true;\n          }\n        }\n        topEdgeFirstx = !topEdgeFirstx;\n        if (topEdgeFirstx) {\n          edgex = Square_TopMove[edgex];\n          prun1 = SquarePrun[edgex << 1 | ml];\n          m += 1;\n        } else {\n          cornerx = Square_TopMove[cornerx];\n          prun2 = SquarePrun[cornerx << 1 | ml];\n          m += 2;\n        }\n      }\n    }\n    if (lm <= 1) {\n      botEdgeFirstx = !botEdgeFirst;\n      edgex = botEdgeFirstx ? Square_BottomMove[edge] : edge;\n      cornerx = botEdgeFirstx ? corner : Square_BottomMove[corner];\n      m = botEdgeFirstx ? 1 : 2;\n      prun1 = SquarePrun[edgex << 1 | ml];\n      prun2 = SquarePrun[cornerx << 1 | ml];\n      while (m < (maxl > 3 ? 6 : 12) && prun1 <= maxl && prun1 <= maxl) {\n        if (prun1 < maxl && prun2 < maxl) {\n          obj.Search_move[depth] = -m;\n          if (Search_phase2(obj, edgex, cornerx, topEdgeFirst, botEdgeFirstx, ml, maxl - 1, depth + 1, 2)) {\n            return true;\n          }\n        }\n        botEdgeFirstx = !botEdgeFirstx;\n        if (botEdgeFirstx) {\n          edgex = Square_BottomMove[edgex];\n          prun1 = SquarePrun[edgex << 1 | ml];\n          m += 1;\n        } else {\n          cornerx = Square_BottomMove[cornerx];\n          prun2 = SquarePrun[cornerx << 1 | ml];\n          m += 2;\n        }\n      }\n    }\n    return false;\n  }\n\n  function Search_solution(obj, c) {\n    var shape;\n    obj.Search_c = c;\n    shape = FullCube_getShapeIdx(c);\n    for (obj.Search_length1 = ShapePrun[shape]; obj.Search_length1 < 100; ++obj.Search_length1) {\n      obj.Search_maxlen2 = Math.min(31 - obj.Search_length1, 17);\n      if (Search_phase1(obj, shape, ShapePrun[shape], obj.Search_length1, 0, -1)) {\n        break;\n      }\n    }\n    return obj.Search_sol_string;\n  }\n\n  function Search_Search() {\n    this.Search_move = [];\n    this.Search_d = new FullCube_FullCube__Ljava_lang_String_2V();\n    this.Search_sq = new Square_Square();\n  }\n\n  function Shape_$clinit() {\n    Shape_halflayer = [\n            0,\n            3,\n            6,\n            12,\n            15,\n            24,\n            27,\n            30,\n            48,\n            51,\n            54,\n            60,\n            63\n        ];\n    Shape_ShapeIdx = [];\n    ShapePrun = [];\n    Shape_TopMove = [];\n    Shape_BottomMove = [];\n    Shape_TwistMove = [];\n    Shape_init();\n  }\n\n  function Shape_bottomMove(obj) {\n    var move, moveParity;\n    move = 0;\n    moveParity = 0;\n    do {\n      if ((obj.bottom & 2048) === 0) {\n        move += 1;\n        obj.bottom = obj.bottom << 1;\n      } else {\n        move += 2;\n        obj.bottom = obj.bottom << 2 ^ 12291;\n      }\n      moveParity = 1 - moveParity;\n    } while ((bitCount(obj.bottom & 63) & 1) !== 0);\n    (bitCount(obj.bottom) & 2) === 0 && (obj.Shape_parity ^= moveParity);\n    return move;\n  }\n\n  function Shape_getIdx(obj) {\n    var ret;\n    ret = binarySearch(Shape_ShapeIdx, obj.top << 12 | obj.bottom) << 1 | obj.Shape_parity;\n    return ret;\n  }\n\n  function Shape_setIdx(obj, idx) {\n    obj.Shape_parity = idx & 1;\n    obj.top = Shape_ShapeIdx[~~idx >> 1];\n    obj.bottom = obj.top & 4095;\n    obj.top >>= 12;\n  }\n\n  function Shape_topMove(obj) {\n    var move, moveParity;\n    move = 0;\n    moveParity = 0;\n    do {\n      if ((obj.top & 2048) === 0) {\n        move += 1;\n        obj.top = obj.top << 1;\n      } else {\n        move += 2;\n        obj.top = obj.top << 2 ^ 12291;\n      }\n      moveParity = 1 - moveParity;\n    } while ((bitCount(obj.top & 63) & 1) !== 0);\n    (bitCount(obj.top) & 2) === 0 && (obj.Shape_parity ^= moveParity);\n    return move;\n  }\n\n  function Shape_Shape() {}\n\n  function Shape_getShape2Idx(shp) {\n    var ret;\n    ret = binarySearch(Shape_ShapeIdx, shp & 16777215) << 1 | ~~shp >> 24;\n    return ret;\n  }\n\n  function Shape_init() {\n    var count, depth, dl, done, done0, dr, i, idx, m, s, ul, ur, value, p1, p3, temp;\n    count = 0;\n    for (i = 0; i < 28561; ++i) {\n      dr = Shape_halflayer[i % 13];\n      dl = Shape_halflayer[~~(i / 13) % 13];\n      ur = Shape_halflayer[~~(~~(i / 13) / 13) % 13];\n      ul = Shape_halflayer[~~(~~(~~(i / 13) / 13) / 13)];\n      value = ul << 18 | ur << 12 | dl << 6 | dr;\n      bitCount(value) === 16 && (Shape_ShapeIdx[count++] = value);\n    }\n    s = new Shape_Shape();\n    for (i = 0; i < 7356; ++i) {\n      Shape_setIdx(s, i);\n      Shape_TopMove[i] = Shape_topMove(s);\n      Shape_TopMove[i] |= Shape_getIdx(s) << 4;\n      Shape_setIdx(s, i);\n      Shape_BottomMove[i] = Shape_bottomMove(s);\n      Shape_BottomMove[i] |= Shape_getIdx(s) << 4;\n      Shape_setIdx(s, i);\n      temp = s.top & 63;\n      p1 = bitCount(temp);\n      p3 = bitCount(s.bottom & 4032);\n      s.Shape_parity ^= 1 & ~~(p1 & p3) >> 1;\n      s.top = s.top & 4032 | ~~s.bottom >> 6 & 63;\n      s.bottom = s.bottom & 63 | temp << 6;\n      Shape_TwistMove[i] = Shape_getIdx(s);\n    }\n    for (i = 0; i < 7536; ++i) {\n      ShapePrun[i] = -1;\n    }\n    ShapePrun[Shape_getShape2Idx(14378715)] = 0;\n    ShapePrun[Shape_getShape2Idx(31157686)] = 0;\n    ShapePrun[Shape_getShape2Idx(23967451)] = 0;\n    ShapePrun[Shape_getShape2Idx(7191990)] = 0;\n    done = 4;\n    done0 = 0;\n    depth = -1;\n    while (done !== done0) {\n      done0 = done;\n      ++depth;\n      for (i = 0; i < 7536; ++i) {\n        if (ShapePrun[i] === depth) {\n          m = 0;\n          idx = i;\n          do {\n            idx = Shape_TopMove[idx];\n            m += idx & 15;\n            idx >>= 4;\n            if (ShapePrun[idx] === -1) {\n              ++done;\n              ShapePrun[idx] = depth + 1;\n            }\n          } while (m !== 12);\n          m = 0;\n          idx = i;\n          do {\n            idx = Shape_BottomMove[idx];\n            m += idx & 15;\n            idx >>= 4;\n            if (ShapePrun[idx] === -1) {\n              ++done;\n              ShapePrun[idx] = depth + 1;\n            }\n          } while (m !== 12);\n          idx = Shape_TwistMove[i];\n          if (ShapePrun[idx] === -1) {\n            ++done;\n            ShapePrun[idx] = depth + 1;\n          }\n        }\n      }\n    }\n  }\n\n  var Shape_BottomMove, Shape_ShapeIdx, ShapePrun, Shape_TopMove, Shape_TwistMove, Shape_halflayer;\n\n  function Square_$clinit() {\n    SquarePrun = [];\n    Square_TwistMove = [];\n    Square_TopMove = [];\n    Square_BottomMove = [];\n    fact = [\n            1,\n            1,\n            2,\n            6,\n            24,\n            120,\n            720,\n            5040\n        ];\n    Cnk = [];\n    for (var i = 0; i < 12; ++i)\n      Cnk[i] = [];\n    Square_init();\n  }\n\n  function Square_Square() {}\n\n  function get8Perm(arr) {\n    var i, idx, v, val;\n    idx = 0;\n    val = 1985229328;\n    for (i = 0; i < 7; ++i) {\n      v = arr[i] << 2;\n      idx = (8 - i) * idx + (~~val >> v & 7);\n      val -= 286331152 << v;\n    }\n    return idx & 65535;\n  }\n\n  function Square_init() {\n    var check, depth, done, find, i, idx, idxx, inv, j, m, ml, pos, temp;\n    for (i = 0; i < 12; ++i) {\n      Cnk[i][0] = 1;\n      Cnk[i][i] = 1;\n      for (j = 1; j < i; ++j) {\n        Cnk[i][j] = Cnk[i - 1][j - 1] + Cnk[i - 1][j];\n      }\n    }\n    pos = [];\n    for (i = 0; i < 40320; ++i) {\n      set8Perm(pos, i);\n      temp = pos[2];\n      pos[2] = pos[4];\n      pos[4] = temp;\n      temp = pos[3];\n      pos[3] = pos[5];\n      pos[5] = temp;\n      Square_TwistMove[i] = get8Perm(pos);\n      set8Perm(pos, i);\n      temp = pos[0];\n      pos[0] = pos[1];\n      pos[1] = pos[2];\n      pos[2] = pos[3];\n      pos[3] = temp;\n      Square_TopMove[i] = get8Perm(pos);\n      set8Perm(pos, i);\n      temp = pos[4];\n      pos[4] = pos[5];\n      pos[5] = pos[6];\n      pos[6] = pos[7];\n      pos[7] = temp;\n      Square_BottomMove[i] = get8Perm(pos);\n    }\n    for (i = 0; i < 80640; ++i) {\n      SquarePrun[i] = -1;\n    }\n    SquarePrun[0] = 0;\n    depth = 0;\n    done = 1;\n    while (done < 80640) {\n      inv = depth >= 11;\n      find = inv ? -1 : depth;\n      check = inv ? depth : -1;\n      ++depth;\n      OUT: for (i = 0; i < 80640; ++i) {\n        if (SquarePrun[i] === find) {\n          idx = ~~i >> 1;\n          ml = i & 1;\n          idxx = Square_TwistMove[idx] << 1 | 1 - ml;\n          if (SquarePrun[idxx] === check) {\n            ++done;\n            SquarePrun[inv ? i : idxx] = ~~ (depth << 24) >> 24;\n            if (inv)\n              continue OUT;\n          }\n          idxx = idx;\n          for (m = 0; m < 4; ++m) {\n            idxx = Square_TopMove[idxx];\n            if (SquarePrun[idxx << 1 | ml] === check) {\n              ++done;\n              SquarePrun[inv ? i : idxx << 1 | ml] = ~~ (depth << 24) >> 24;\n              if (inv)\n                continue OUT;\n            }\n          }\n          for (m = 0; m < 4; ++m) {\n            idxx = Square_BottomMove[idxx];\n            if (SquarePrun[idxx << 1 | ml] === check) {\n              ++done;\n              SquarePrun[inv ? i : idxx << 1 | ml] = ~~ (depth << 24) >> 24;\n              if (inv)\n                continue OUT;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function set8Perm(arr, idx) {\n    var i, m, p, v, val;\n    val = 1985229328;\n    for (i = 0; i < 7; ++i) {\n      p = fact[7 - i];\n      v = ~~ (idx / p);\n      idx -= v * p;\n      v <<= 2;\n      arr[i] = ~~ ((~~val >> v & 7) << 24) >> 24;\n      m = (1 << v) - 1;\n      val = (val & m) + (~~val >> 4 & ~m);\n    }\n    arr[7] = ~~ (val << 24) >> 24;\n  }\n\n  var Square_BottomMove, Cnk, SquarePrun, Square_TopMove, Square_TwistMove, fact;\n\n  function bitCount(x) {\n    x -= ~~x >> 1 & 1431655765;\n    x = (~~x >> 2 & 858993459) + (x & 858993459);\n    x = (~~x >> 4) + x & 252645135;\n    x += ~~x >> 8;\n    x += ~~x >> 16;\n    return x & 63;\n  }\n\n  function binarySearch(sortedArray, key) {\n    var high, low, mid, midVal;\n    low = 0;\n    high = sortedArray.length - 1;\n    while (low <= high) {\n      mid = low + (~~(high - low) >> 1);\n      midVal = sortedArray[mid];\n      if (midVal < key) {\n        low = mid + 1;\n      } else if (midVal > key) {\n        high = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n    return -low - 1;\n  }\n  var square1Solver_initialized = false;\n  var square1SolverInitialize = function (iniRandomSource) {\n    setRandomSource(iniRandomSource);\n    if (!square1Solver_initialized) {\n      Shape_$clinit();\n      Square_$clinit();\n    }\n    square1Solver_initialized = true;\n  };\n  var square1SolverRandomSource;\n  var setRandomSource = function (src) {\n    square1SolverRandomSource = src;\n  };\n  var square1SolverGetRandomPosition = function () {\n    if (!square1Solver_initialized) {\n      square1SolverInitialize();\n    }\n    return FullCube_randomCube();\n  };\n  var square1SolverGenerate = function (state) {\n    var search_search = new Search_Search();\n    return Search_solution(search_search, state);\n  };\n  var square1SolverGetRandomScramble = function () {\n    var randomState = square1SolverGetRandomPosition();\n    var scrambleString = square1SolverGenerate(randomState);\n    return scrambleString;\n  };\n  var setScrambleLength = function (length) {\n    return null;\n  };\n  return {\n    initialize: square1SolverInitialize,\n    setRandomSource: setRandomSource,\n    getRandomScramble: square1SolverGetRandomScramble,\n    setScrambleLength: setScrambleLength\n  };\n}();\nmodule.exports = scrambler;\n\n\n//# sourceURL=webpack://rubiks-bld-project/../../../node_modules/scrambo/lib/scramblers/sq1.js?\n}");

/***/ }),

/***/ "../../../node_modules/scrambo/lib/scrambo.js":
/*!****************************************************!*\
  !*** ../../../node_modules/scrambo/lib/scrambo.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{/* jshint node: true */\n\nvar util = __webpack_require__(/*! ./util.js */ \"../../../node_modules/scrambo/lib/util.js\");\n\nvar scramblers = {};\nscramblers = __webpack_require__(/*! ./scramblers/NNN.js */ \"../../../node_modules/scrambo/lib/scramblers/NNN.js\");\nscramblers.clock = __webpack_require__(/*! ./scramblers/clock.js */ \"../../../node_modules/scrambo/lib/scramblers/clock.js\");\nscramblers.minx = __webpack_require__(/*! ./scramblers/minx.js */ \"../../../node_modules/scrambo/lib/scramblers/minx.js\");\nscramblers.pyram = __webpack_require__(/*! ./scramblers/pyram.js */ \"../../../node_modules/scrambo/lib/scramblers/pyram.js\");\nscramblers.sq1 = __webpack_require__(/*! ./scramblers/sq1.js */ \"../../../node_modules/scrambo/lib/scramblers/sq1.js\");\nscramblers.skewb = __webpack_require__(/*! ./scramblers/skewb.js */ \"../../../node_modules/scrambo/lib/scramblers/skewb.js\");\n\n/**\n * A scramble generator\n * @constructor\n */\nfunction Scrambo() {\n\n\tthis.t = '333';\n\tthis.l = 20;\n\tthis.s = Math;\n\n\tthis.length(this.l);\n\n\tthis.type(this.t);\n\n\treturn this;\n}\n\n/**\n * Gets/Sets scramble type\n * @param {string} type scramble type\n * @returns {string} set type\n */\nScrambo.prototype.type = function(type) {\n\tif (!arguments.length) return this.t;\n\n\tthis.t = type;\n\n\tthis.init();\n\n\treturn this;\n};\n\n/**\n * Return a scramble\n * @param {number} num number of scrambles\n * @returns {string} generated scramble\n */\nScrambo.prototype.get = function(num) {\n  num = num || 1;\n\n\tvar stack = [];\n\tfor(var i = 0; i < num; i++) {\n\t\tstack.push(scramblers[this.t].getRandomScramble());\n\t}\n\n\treturn stack;\n};\n\n/**\n * Sets the seed\n * @param {num|Math} random source\n */\nScrambo.prototype.seed = function(seed) {\n\tif (!arguments.length) return this.s;\n\n\t// Force to string so we get consistent seeds.\n\tseed = seed + '';\n\t// Hash the string into a number.\n\tseed = util.hashCode(seed);\n\t// http://stackoverflow.com/a/19303725\n\tthis.s = {\n\t\trandom: function() {\n\t\t\tvar x = Math.sin(seed++) * 10000;\n    \t\treturn x - Math.floor(x);\n\t\t}\n\t};\n\n\tthis.init();\n\n\treturn this;\n};\n\n/**\n * Gets/Sets the scramble length\n * @param {num|Math} random source\n */\nScrambo.prototype.length = function(length) {\n\tif (!arguments.length) return this.l;\n\n\tthis.l = length;\n\n\tscramblers[this.t].setScrambleLength(this.l);\n\n\treturn this;\n};\n\n/**\n * Initializes the scrambler\n */\nScrambo.prototype.init = function() {\n\n\t// Check the scrambler exists.\n\tif(!scramblers.hasOwnProperty(this.t)){\n\t\tthrow new Error('invalid scrambler, allowed: ' + Object.keys(scramblers));\n\t}\n\n\tscramblers[this.t].initialize(this.s);\n};\n\nmodule.exports = Scrambo;\n\n//# sourceURL=webpack://rubiks-bld-project/../../../node_modules/scrambo/lib/scrambo.js?\n}");

/***/ }),

/***/ "../../../node_modules/scrambo/lib/util.js":
/*!*************************************************!*\
  !*** ../../../node_modules/scrambo/lib/util.js ***!
  \*************************************************/
/***/ ((module) => {

eval("{/* jshint node: true */\n\n// http://stackoverflow.com/a/7616484\n// Allows string seeds yay!\nmodule.exports.hashCode = function(str) {\n  var hash = 0, i, chr, len;\n    /* istanbul ignore if */\n  if (str.length === 0) return hash;\n  for (i = 0, len = str.length; i < len; i++) {\n    chr   = str.charCodeAt(i);\n    hash  = ((hash << 5) - hash) + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return hash;\n};\n\n\n//# sourceURL=webpack://rubiks-bld-project/../../../node_modules/scrambo/lib/util.js?\n}");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("{var Scrambo = __webpack_require__(/*! scrambo */ \"../../../node_modules/scrambo/lib/scrambo.js\");\r\n\r\nvar threebythree = new Scrambo(); \r\n\r\nfunction getNewScramble() {\r\n    return threebythree.get(1)[0];\r\n}\r\n\r\nlet scramble = getNewScramble()\r\n\r\ndocument.getElementById(\"scramble\").innerHTML = scramble\r\n\r\nlet timer = null;\r\nlet startTime = 0;\r\nlet elapsedTime = 0;\r\nlet isRunning = false;\r\nlet stopped = false;\r\n\r\nlet holdTime = 0.5\r\nlet down = false;\r\nlet primed = false;\r\nlet primeTimeout = null;\r\n\r\nlet stage = 0;\r\n\r\nlet timerDisplay = document.getElementById(\"timerDisplay\")\r\nlet memoInput = document.getElementById(\"memoInput\")\r\nlet memoDisplay = document.getElementById(\"memoDisplay\")\r\nlet memoIndicator = document.getElementById(\"memoIndicator\")\r\n\r\nwindow.setup = function(){\r\n    createCanvas(400, 400);\r\n    maincube = new cube();\r\n    maincube.executeAlg(scramble);\r\n}\r\n\r\nfunction startTimer() {\r\n    if(!isRunning){\r\n    startTime = Date.now() - elapsedTime;\r\n    timer = setInterval(update, 10);\r\n    isRunning = true;\r\n    }\r\n}\r\n\r\nfunction stopTimer() {\r\n    if(isRunning){\r\n    clearInterval(timer);\r\n    elapsedTime = Date.now() - startTime;\r\n    isRunning = false;\r\n    if(stage == 0){\r\n      stage = 1;\r\n      memoInput.style.display = \"block\";\r\n      memoDisplay.style.display = \"block\";\r\n      updateMemoIndicator();\r\n      \r\n    }else if(stage == 1){\r\n    //get new scramble and reload dom element\r\n    scramble = getNewScramble();\r\n    document.getElementById(\"scramble\").innerHTML = scramble;\r\n    //reload cube and p5 display\r\n    window.maincube = new cube();\r\n    window.maincube.executeAlg(scramble);\r\n    stage = 0;\r\n    updateMemoIndicator();\r\n    }\r\n    }\r\n}\r\n\r\nfunction updateMemoIndicator() {\r\n    if(stage == 0){\r\n        memoIndicator.innerHTML = \"MEMO\";\r\n    } else if(stage == 1){\r\n        memoIndicator.innerHTML = \"EXEC\";\r\n    }\r\n}\r\n\r\nfunction reset() {\r\n    clearInterval(timer);\r\n    startTime = 0;\r\n    elapsedTime = 0;\r\n    isRunning = false;\r\n    timerDisplay.textContent = \"0.00\"\r\n}\r\n\r\nfunction update() {\r\n    const currentTime = Date.now();\r\n    elapsedTime = currentTime - startTime;\r\n     \r\n    let hours = Math.floor(elapsedTime / (1000*60*60));\r\n    let minutes = Math.floor(elapsedTime / (1000*60) % 60);\r\n    let seconds = Math.floor(elapsedTime / 1000 % 60);\r\n    let milliseconds = Math.floor(elapsedTime % 1000 / 10);\r\n\r\n    let timeString = \"\";\r\n\r\n    if (hours > 0) {\r\n        timeString += hours + \":\";\r\n        timeString += minutes.toString().padStart(2, '0') + \":\";\r\n    } else if (minutes > 0) {\r\n        timeString += minutes + \":\";\r\n    }\r\n    timeString += seconds.toString() + \".\";\r\n    timeString += milliseconds.toString().padStart(2, '0');\r\n\r\n    timerDisplay.textContent = timeString;\r\n}\r\n\r\ndocument.addEventListener(\"keyup\", event => {\r\n\r\n        if (event.code !== \"Space\" || document.activeElement.tagName === \"INPUT\") {\r\n            return;\r\n        }\r\n\r\n        if(!stopped&&primed){\r\n        startTimer()\r\n        }else{\r\n        stopped = false\r\n        }\r\n        down = false;\r\n        primed = false;\r\n        if(primeTimeout) {\r\n            clearTimeout(primeTimeout);\r\n            primeTimeout = null;\r\n        }\r\n        timerDisplay.style.color = \"black\"\r\n})\r\n\r\ndocument.addEventListener(\"keydown\", event => {\r\n\r\n\r\n    if (event.code !== \"Space\" || document.activeElement.tagName === \"INPUT\") {\r\n        return;\r\n    }\r\n\r\n    if(stage==1){\r\n      memoInput.style.display = \"none\";\r\n      memoDisplay.style.display = \"none\";\r\n      memoInput.value = \"\";\r\n      memoDisplay.textContent = \"\";\r\n    }\r\n\r\n        \r\n    if(!isRunning){\r\n        if(!primed){\r\n           timerDisplay.style.color = \"red\" \r\n           reset()\r\n           primeTimeout = setTimeout(() => {\r\n            if(!isRunning){\r\n            timerDisplay.style.color = \"green\"\r\n            primed=true\r\n            }\r\n           },holdTime*1000)\r\n        }\r\n    }else if(isRunning){\r\n            stopped = true\r\n        }\r\n        stopTimer()\r\n\r\n})\r\n\r\nmemoInput.addEventListener(\"keydown\", function(event) {\r\n    if (event.key === \"Enter\") {\r\n        const memoString = memoInput.value.toUpperCase();\r\n        memoDisplay.textContent = memoString;\r\n        let[edgeMemo,cornerMemo] = memoString.split(\" \")\r\n        edgeMemo = edgeMemo.split(\"\")\r\n        cornerMemo = cornerMemo.split(\"\")\r\n        let testcube = new cube();\r\n        testcube.executeAlg(scramble)\r\n        testcube.swapEdgeMemo(edgeMemo);\r\n        testcube.swapCornerMemo(cornerMemo);\r\n        if(testcube.areEdgesSolved() && testcube.areCornersSolved()){\r\n          memoDisplay.style = \"color: green\"\r\n        }else{\r\n          memoDisplay.style = \"color: red\"\r\n        }\r\n        \r\n        memoInput.blur();\r\n        console.log(\"edgeMemo = \" + edgeMemo + \" cornerMemo = \" + cornerMemo)\r\n        memoDisplay.style.display = \"block\";\r\n      }\r\n});\r\n\r\n\r\n// cube logic //\r\n\r\nfunction convertNotation(scrambleString) {\r\n    // Split by spaces to get individual moves\r\n    const moves = scrambleString.split(' ');\r\n    const result = [];\r\n    \r\n    for (let move of moves) {\r\n        move = move.trim();\r\n        if (move === '') continue;\r\n        \r\n        const face = move[0].toLowerCase();\r\n    \r\n        if (move.includes(\"'\")) {\r\n            result.push(face.toUpperCase());\r\n        } else if (move.includes(\"2\")) {\r\n            result.push(face, face);\r\n        } else {\r\n            result.push(face);\r\n        }\r\n    }\r\n    \r\n    return result;\r\n}\r\n\r\n\r\n class cube{\r\n    constructor(){\r\n      this.faces = {\r\n        Uface: this.createface('W'),  \r\n        Dface: this.createface('Y'),\r\n        Lface: this.createface('O'),\r\n        Fface: this.createface('G'),\r\n        Rface: this.createface('R'),\r\n        Bface: this.createface('B'),\r\n      }\r\n      \r\n      this.faceColor = {\r\n        'W': 'Uface',\r\n        'Y': 'Dface', \r\n        'O': 'Lface',\r\n        'G': 'Fface',\r\n        'R': 'Rface',\r\n        'B': 'Bface'\r\n      };\r\n      \r\n      this.colours = {\r\n        'W': [255, 255, 255], // White\r\n        'Y': [255, 255, 0],   // Yellow\r\n        'O': [255, 165, 0],   // Orange\r\n        'G': [0, 255, 0],     // Green\r\n        'R': [255, 0, 0],     // Red\r\n        'B': [0, 0, 255]      // Blue\r\n      };\r\n      \r\n      this.adjSides = {\r\n      'Uface': [\r\n        [0,0], [0,1], [0,2],  // Fface top row \r\n        [0,0], [0,1], [0,2],  // Rface top row  \r\n        [0,0], [0,1], [0,2],  // Bface top row\r\n        [0,0], [0,1], [0,2]   // Lface top row\r\n      ],\r\n      'Dface': [\r\n        [2,0], [2,1], [2,2],  // Fface bottom row\r\n        [2,0], [2,1], [2,2],  // Rface bottom row\r\n        [2,0], [2,1], [2,2],  // Bface bottom row\r\n        [2,0], [2,1], [2,2]   // Lface bottom row\r\n      ],\r\n      'Fface': [\r\n        [0,0], [0,1], [0,2],  // Bface top row\r\n        [2,0], [1,0], [0,0],  // Rface left column\r\n        [2,2], [2,1], [2,0],  // Uface top row\r\n        [0,2], [1,2], [2,2]   // Lface right column\r\n      ],\r\n\r\n      'Bface': [\r\n        [2,2], [2,1], [2,0],  // Dface bottom row\r\n        [2,0], [1,0], [0,0],  // Lface left column\r\n        [0,0], [0,1], [0,2],  // Uface bottom row \r\n        [0,2], [1,2], [2,2]   // Rface right column \r\n      ],\r\n      'Rface': [\r\n        [0,2], [1,2], [2,2],  // Dface right column\r\n        [2,0], [1,0], [0,0],   // Bface left column\r\n        [0,2], [1,2], [2,2],  // Uface right column\r\n        [0,2], [1,2], [2,2]  // Fface right column\r\n        \r\n      ],\r\n      'Lface': [\r\n        [2,0], [1,0], [0,0],  // Dface left column\r\n        [2,0], [1,0], [0,0],   // Fface left column\r\n        [2,0], [1,0], [0,0],  // Uface left column \r\n        [0,2], [1,2], [2,2]  // Bface right column\r\n      ]\r\n        \r\n    }\r\n      \r\n    this.adjFaces = {\r\n      'Uface': ['Fface', 'Rface', 'Bface', 'Lface'],\r\n      'Dface': ['Bface', 'Rface', 'Fface', 'Lface'],\r\n      'Fface': ['Dface', 'Rface', 'Uface', 'Lface'],\r\n      'Bface': ['Dface', 'Lface', 'Uface', 'Rface'],\r\n      'Rface': ['Dface', 'Bface', 'Uface', 'Fface'],\r\n      'Lface': ['Dface', 'Fface', 'Uface', 'Bface']\r\n    };\r\n      \r\n    this.corners = {\r\n      AER: [['Uface', 0, 0],['Lface', 0, 0],['Bface', 0, 2]],\r\n      BQN: [['Uface', 0, 2],['Bface', 0, 0],['Rface', 0, 2]],\r\n      CMJ: [['Uface', 2, 2],['Rface', 0, 0],['Fface', 0, 2]],\r\n      DIF: [['Uface', 2, 0],['Fface', 0, 0],['Lface', 0, 2]],\r\n      UGL: [['Dface', 0, 0],['Lface', 2, 2],['Fface', 2, 0]],\r\n      VKP: [['Dface', 0, 2],['Fface', 2, 2],['Rface', 2, 0]],\r\n      WOT: [['Dface', 2, 2],['Rface', 2, 2],['Bface', 2, 0]],\r\n      XSH: [['Dface', 2, 0],['Bface', 2, 2],['Lface', 2, 0]]\r\n    }\r\n      \r\n    this.letters = {\r\n      'Uface':[['A','A','B'],\r\n               ['D',null,'B'],\r\n               ['D','C','C']\r\n               ],\r\n      'Lface':[['E','E','F'],\r\n               ['H',null,'F'],\r\n               ['H','G','G']\r\n               ],\r\n      'Fface':[['I','I','J'],\r\n               ['L',null,'J'],\r\n               ['L','K','K']\r\n               ],\r\n      'Rface':[['M','M','N'],\r\n               ['P',null,'N'],\r\n               ['P','O','O']\r\n               ],\r\n      'Bface':[['Q','Q','R'],\r\n               ['T',null,'R'],\r\n               ['T','S','S']\r\n               ],\r\n      'Dface':[['U','U','V'],\r\n               ['X',null,'V'],\r\n               ['X','W','W']\r\n               ],\r\n\r\n    }\r\n    \r\n      this.edgeBuffer = ['Uface', 1, 2]\r\n      \r\n      this.cornerBuffer = ['Lface', 0, 0]\r\n  }\r\n    \r\n    \r\n  createface(colour){\r\n    return[\r\n    [colour,colour,colour],\r\n    [colour,colour,colour],\r\n    [colour,colour,colour]\r\n  ]\r\n  }\r\n    \r\n    turnFace(face,direction){\r\n      let topface = [\r\n        face[0][0], face[0][1], face[0][2],\r\n        face[1][2], face[2][2],\r\n        face[2][1], face[2][0],\r\n        face[1][0]\r\n      ]\r\n    \r\n      let shifted = []\r\n      \r\n      if (direction === 'cw') {\r\n        shifted = shiftArray(topface, -2);\r\n      } else if (direction === 'acw') {\r\n        shifted = shiftArray(topface, 2);\r\n      }\r\n      \r\n      face[0][0] = shifted[0]\r\n      face[0][1] = shifted[1]\r\n      face[0][2] = shifted[2]\r\n      face[1][2] = shifted[3]\r\n      face[2][2] = shifted[4]\r\n      face[2][1] = shifted[5]\r\n      face[2][0] = shifted[6]\r\n      face[1][0] = shifted[7]\r\n    }\r\n    \r\n  turnAdj(face, direction){\r\n    let positions = this.adjSides[face];\r\n    let faceNames = this.adjFaces[face];\r\n    \r\n    let sidePieces = [];\r\n    for (let i = 0; i < positions.length; i++) {\r\n      let pos = positions[i];\r\n      let faceIndex = Math.floor(i / 3);\r\n      let targetFace = this.faces[faceNames[faceIndex]];\r\n      sidePieces.push(targetFace[pos[0]][pos[1]]);\r\n    }\r\n    \r\n    let shifted = [];\r\n    \r\n    if (direction === 'cw') {\r\n      shifted = shiftArray(sidePieces, 3);\r\n    } else if (direction === 'acw') {\r\n      shifted = shiftArray(sidePieces, -3);\r\n    }\r\n\r\n    for (let i = 0; i < positions.length; i++) {\r\n      let pos = positions[i];\r\n      let faceIndex = Math.floor(i / 3);\r\n      let targetFace = this.faces[faceNames[faceIndex]];\r\n      targetFace[pos[0]][pos[1]] = shifted[i];\r\n    }\r\n  }\r\n    \r\n  turn(faceName, direction){\r\n    this.turnFace(this.faces[faceName], direction);\r\n    this.turnAdj(faceName, direction);\r\n  }\r\n  \r\n    drawFace(face, x, y, size){\r\n      for(let row = 0; row < face.length; row++){\r\n        for(let col = 0; col < face[row].length; col++){\r\n          let square = this.colours[face[row][col]];\r\n          fill(square);\r\n          let squareX = x + (col * size);\r\n          let squareY = y + (row * size);\r\n          rect(squareX,squareY,size)\r\n        }\r\n      }\r\n    }\r\n    \r\n    makeTurn(n){\r\n        if(n=='u') {\r\n        this.turn('Uface', 'cw')\r\n        }\r\n        if(n=='U') {\r\n        this.turn('Uface', 'acw')\r\n        }\r\n        if(n=='d') {\r\n        this.turn('Dface', 'cw')\r\n        }\r\n        if(n=='D') {\r\n        this.turn('Dface', 'acw')\r\n        }\r\n        if(n=='l') {\r\n        this.turn('Lface', 'cw')\r\n        }\r\n        if(n=='L') {\r\n        this.turn('Lface', 'acw')\r\n        }\r\n        if(n=='f') {\r\n        this.turn('Fface', 'cw')\r\n        }\r\n        if(n=='F') {\r\n        this.turn('Fface', 'acw')\r\n        }\r\n        if(n=='r') {\r\n        this.turn('Rface', 'cw')\r\n        }\r\n        if(n=='R') {\r\n        this.turn('Rface', 'acw')\r\n        }\r\n        if(n=='b') {\r\n        this.turn('Bface', 'cw')\r\n        }\r\n        if(n=='B') {\r\n        this.turn('Bface', 'acw')\r\n        }\r\n  \r\n    }\r\n    \r\n    executeAlg(alg){\r\n\r\n        if(typeof alg == \"string\"){\r\n            alg = convertNotation(alg)\r\n        }\r\n      for(let j=0;j<alg.length;j++){\r\n        this.makeTurn(alg[j])\r\n      }\r\n    }\r\n    \r\n    drawNet(x,y,size){\r\n        this.drawFace(this.faces.Uface,x+size*3,y,size)\r\n        this.drawFace(this.faces.Lface,x -5,y+size*3+5,size)\r\n        this.drawFace(this.faces.Fface,x+size*3,y+size*3+5,size)\r\n        this.drawFace(this.faces.Rface,x+size*6 + 5,y+size*3+5,size)\r\n        this.drawFace(this.faces.Bface,x+size*9 + 10,y+size*3+5,size)\r\n        this.drawFace(this.faces.Dface,x+size*3,y+size*6+10,size)\r\n    }\r\n    \r\n    findAdjEdge(face,row,col){\r\n      \r\n      let mainFace = this.faces[face][row][col]\r\n      let index = null\r\n      \r\n      if(row == 2 && col == 1){\r\n        index = 0\r\n      }\r\n      if(row == 1 && col == 2){\r\n        index = 1\r\n      }\r\n      if(row == 0 && col == 1){\r\n        index = 2\r\n      }\r\n      if(row == 1 && col == 0){\r\n        index = 3\r\n      }\r\n      \r\n      let adjFace = this.adjFaces[face][index]\r\n      let adjSideIndex = index * 3 + 1; // +1 to get the middle piece of the edge\r\n      let adjCoords = this.adjSides[face][adjSideIndex];\r\n  \r\n    return {\r\n      face: adjFace,\r\n      row: adjCoords[0],\r\n      col: adjCoords[1]\r\n    }; \r\n  }\r\n    \r\n    findAdjCorners(face,row,col){\r\n      \r\n      let cornerInfo = this.findArray(this.corners,[face, row, col])\r\n      let corner1 = this.corners[cornerInfo.key][(cornerInfo.index + 1) % this.corners[cornerInfo.key].length]\r\n      let corner2 = this.corners[cornerInfo.key][(cornerInfo.index + 2) % this.corners[cornerInfo.key].length]\r\n \r\n  \r\n      return{\r\n        face1: corner1[0],\r\n        row1: corner1[1],\r\n        col1: corner1[2],\r\n        \r\n        face2: corner2[0],\r\n        row2: corner2[1],\r\n        col2: corner2[2]\r\n      }\r\n    }\r\n    \r\n   findArray(obj, target) {\r\n  for (const key in obj) {\r\n    const arrays = obj[key];\r\n    for (let i = 0; i < arrays.length; i++) {\r\n      const subArray = arrays[i];\r\n      // Check if arrays are equal\r\n      if (\r\n        subArray.length === target.length &&\r\n        subArray.every((val, idx) => val === target[idx])\r\n      ) {\r\n        return { key, index: i };\r\n      }\r\n    }\r\n  }\r\n  return null; \r\n}\r\n      \r\n    \r\n    \r\n    findDestEdge(face,row,col) {\r\n      let mainEdge = this.faces[face][row][col]\r\n      let adjEdgeinfo = this.findAdjEdge(face,row,col)\r\n      let adjEdge = this.faces[adjEdgeinfo.face][adjEdgeinfo.row][adjEdgeinfo.col]\r\n      \r\n      let destFace = this.faceColor[mainEdge]\r\n      let adjFace = this.faceColor[adjEdge]\r\n      \r\n      let index = this.adjFaces[adjFace].indexOf(destFace)\r\n       \r\n      index = index*3 + 1\r\n      \r\n      let destCoords = this.adjSides[adjFace][index]\r\n      \r\n      return {\r\n        face: destFace,\r\n        row: destCoords[0],\r\n        col: destCoords[1]\r\n      }\r\n    }\r\n    \r\n    searchObj(obj, target) {\r\n      let matches = [];\r\n\r\n      for (const key in obj) {\r\n        const row = obj[key];\r\n        for (let i = 0; i < row.length; i++) {\r\n          const col = row[i];\r\n          for (let j = 0; j < col.length; j++) {\r\n            if (col[j] === target) {\r\n              matches.push({ key, row: i, col: j });\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return matches; \r\n    }\r\n\r\n\r\n    \r\n    isEdgePosition(row, col) {\r\n      return (\r\n      (row === 0 && col === 1) ||\r\n      (row === 1 && col === 0) ||\r\n      (row === 1 && col === 2) ||\r\n      (row === 2 && col === 1)\r\n      );\r\n    }\r\n    \r\n    swapPieces(face1,row1,col1,face2,row2,col2){\r\n      let main1 = this.faces[face1][row1][col1]\r\n      let main2 = this.faces[face2][row2][col2]\r\n      \r\n      this.faces[face1][row1][col1] = main2\r\n      this.faces[face2][row2][col2] = main1\r\n      \r\n      if(this.isEdgePosition(row1,col1) && this.isEdgePosition(row2,col2)){\r\n      let adjCoord1 = this.findAdjEdge(face1, row1, col1)\r\n      let adjCoord2 = this.findAdjEdge(face2, row2, col2)\r\n      let adj1 = this.faces[adjCoord1.face][adjCoord1.row][adjCoord1.col]\r\n      let adj2 = this.faces[adjCoord2.face][adjCoord2.row][adjCoord2.col]\r\n      \r\n\r\n\r\n      this.faces[adjCoord1.face][adjCoord1.row][adjCoord1.col] = adj2\r\n      this.faces[adjCoord2.face][adjCoord2.row][adjCoord2.col] = adj1   \r\n      \r\n      }else if(!this.isEdgePosition(row1,col1) && !this.isEdgePosition(row2,col2)){\r\n        \r\n      let corner1 = this.findAdjCorners(face1, row1, col1)\r\n      let corner2 = this.findAdjCorners(face2, row2, col2)\r\n\r\n      let corner1_adj1 = this.faces[corner1.face1][corner1.row1][corner1.col1]\r\n      let corner1_adj2 = this.faces[corner1.face2][corner1.row2][corner1.col2]\r\n      let corner2_adj1 = this.faces[corner2.face1][corner2.row1][corner2.col1]\r\n      let corner2_adj2 = this.faces[corner2.face2][corner2.row2][corner2.col2]\r\n\r\n      this.faces[corner1.face1][corner1.row1][corner1.col1] = corner2_adj1\r\n      this.faces[corner1.face2][corner1.row2][corner1.col2] = corner2_adj2\r\n      this.faces[corner2.face1][corner2.row1][corner2.col1] = corner1_adj1\r\n      this.faces[corner2.face2][corner2.row2][corner2.col2] = corner1_adj2\r\n    }\r\n    }\r\n    \r\n    swapEdgeMemo(memo) {\r\n      for (let i = 0; i < memo.length; i++) {\r\n        let matches = this.searchObj(this.letters, memo[i]);\r\n        let mainFace = matches.find(pos => this.isEdgePosition(pos.row, pos.col));\r\n\r\n        if (mainFace) {\r\n          this.swapPieces(mainFace.key,mainFace.row,mainFace.col,\r\n                     this.edgeBuffer[0],this.edgeBuffer[1],this.edgeBuffer[2])\r\n        }\r\n\r\n      }\r\n    }\r\n    \r\n    swapCornerMemo(memo){\r\n      for (let i=0; i< memo.length; i++){\r\n        let matches = this.searchObj(this.letters, memo[i]);\r\n        let mainFace = matches.find(pos => !this.isEdgePosition(pos.row, pos.col));\r\n\r\n        if (mainFace) {\r\n          this.swapPieces(mainFace.key,mainFace.row,mainFace.col,\r\n                     this.cornerBuffer[0],this.cornerBuffer[1],this.cornerBuffer[2])\r\n        }    \r\n      }\r\n    }\r\n\r\n    isPieceSolved(face,row,col){\r\n      let mainface = this.faces[face][row][col]\r\n      if(face != this.faceColor[mainface]){\r\n        return false;\r\n      }\r\n      if(this.isEdgePosition(row,col)){\r\n        let adjCoord = this.findAdjEdge(face,row,col);\r\n        let adjColor = this.faces[adjCoord.face][adjCoord.row][adjCoord.col]\r\n        if(adjCoord.face != this.faceColor[adjColor]){\r\n          return false;\r\n        }\r\n      }else{\r\n        let corners = this.findAdjCorners(face,row,col)\r\n        let corner1 = this.faces[corners.face1][corners.row1][corners.col1]\r\n        let corner2 = this.faces[corners.face2][corners.row2][corners.col2]\r\n        if(corners.face1 != this.faceColor[corner1]){\r\n          return false;\r\n        }\r\n        if(corners.face2 != this.faceColor[corner2]){\r\n          return false;\r\n        } \r\n      }\r\n      return true;\r\n    }\r\n    \r\n    areEdgesSolved(){\r\n      if(\r\n      this.isPieceSolved('Uface',0,1)&&\r\n      this.isPieceSolved('Uface',1,2)&&\r\n      this.isPieceSolved('Uface',2,1)&&\r\n      this.isPieceSolved('Uface',1,0)&&\r\n      this.isPieceSolved('Dface',0,1)&&\r\n      this.isPieceSolved('Dface',1,2)&&\r\n      this.isPieceSolved('Dface',2,1)&&\r\n      this.isPieceSolved('Dface',1,0)&&\r\n      this.isPieceSolved('Fface',1,0)&&\r\n      this.isPieceSolved('Fface',1,2)&&\r\n      this.isPieceSolved('Bface',1,0)&&\r\n      this.isPieceSolved('Bface',1,2)){\r\n        return true;\r\n      }else{\r\n        return false;\r\n      }\r\n    }\r\n    areCornersSolved(){\r\n      if(\r\n      this.isPieceSolved('Uface',0,0)&&\r\n      this.isPieceSolved('Uface',0,2)&&\r\n      this.isPieceSolved('Uface',2,0)&&\r\n      this.isPieceSolved('Uface',2,2)&&\r\n      this.isPieceSolved('Dface',0,0)&&\r\n      this.isPieceSolved('Dface',0,2)&&\r\n      this.isPieceSolved('Dface',2,0)&&\r\n      this.isPieceSolved('Dface',2,2)){\r\n        return true;\r\n      }else{\r\n        return false;\r\n      }\r\n    }\r\n}\r\n\r\nfunction shiftArray(arr, n) {\r\n  const len = arr.length;\r\n  const shift = ((n % len) + len) % len;\r\n  return arr.slice(shift).concat(arr.slice(0, shift));\r\n}\r\n\r\nwindow.draw = function(){\r\n    maincube.drawNet(10,10,30);\r\n}\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://rubiks-bld-project/./src/index.js?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;